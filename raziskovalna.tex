\documentclass[12pt]{article}

\usepackage[slovene]{babel}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage{graphicx}
\usepackage{caption}
\usepackage[hidelinks,unicode]{hyperref}
\usepackage{tikz}
\usepackage{tikz-timing}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\renewcommand{\contentsname}{Kazalo}
\renewcommand\listfigurename{Kazalo slik}
\renewcommand{\figurename}{Slika}

\begin{document}
\pagenumbering{gobble}
\linespread{1.25}
\begin{titlepage}
  \begin{center}
    \includegraphics[height=2cm]{slike/vegova.png}\\
    \Huge
    \vspace*{6cm}
    Raziskovanje mej RISCa\\
    \Large
    (računalništvo in informatika)\\
    Raziskovalna naloga\\
  \end{center}
  \vspace{8cm}
  \begin{tabular}{rl}
Avtor: & Adrian Sebastian Šiška\\
Mentor: & Aleš Volčini
    \end{tabular}
    \vspace{1cm}
    \begin{center}
      Ljubljana, marec 2022
    \end{center}
\end{titlepage}

\pagebreak
\pagenumbering{arabic}

\tableofcontents

\pagebreak

\listoffigures

\pagebreak

%\section{Zahvala}
%%TODO
%%Zahvaljujem se vsem, ki so mi pomagali pri raziskovanju in pisanju.
%%Še posebej se zahvaljujem mentorju Alešu Volčiniju za podporo in potrpežljivost.
%%Pomagla sta mi tudi moja prijatelja Anton Luka Šijanec in Oliver Wagner pri iskanju mojih hroščev.
%
%\pagebreak
%
%\section{Povzetek}
%%TODO
%%V tej raziskovalni nalogi sem hotel videti kako se RISC arhitekture obnašajo, ko jih porinemo do njihovih logičnih ekstremov.
%%Da sem ta
%\pagebreak

%%ANG ONLY DEU
%\section{Abstract}

\section{Uvod}
%TODO
V raziskovalni nalogi sem si zadal kot cilj izdelavo minimalistične arhitekture.

\subsection{Hipoteze}
V tej nalogi bom preveril resničnost sledečih hipotez:
\begin{itemize}
  \item Bolj kot je arhitektura preprosta, hitreje in bolj učinkovito deluje.
  \item Moja lahkotna arhitektura je Turing complete.
\end{itemize}

\section{Moja arhitektura}
\begin{figure}[h]
  \centering
  \includegraphics[width=.5\linewidth]{slike/arhitektura.gv.pdf}
  \captionof{figure}{Shematika moje arhitekture}
  \end{figure}

\subsection{Kaj je URISC?}
%URGENTLY religate interesting stuff to the compiler
URISC je angleška kratica, ki pomeni \textit{ultimate reduced instruction set computer}, kar bi lahko v slovenščino prevedli kot \textit{računalnik z dokončno zmanjšano množico operacij}.
RISC arhitekture so v praksi, odkar pomnilnik ni več drag, boljše od CISC arhitektur, to nam dokazujejo moderni pametni telefoni, saj skoraj vsi delujejo na arm čipih.
To nam dokaže tudi najpopularnejši ustvarjalec CISC procesorjev, Intel, saj so dandanes njihovi procesorji interno zgrajeni iz tolmača in manjšega RISC procesorja.
Da arhitkturo označimo kot URISC, pa rabimo iti še en korak dajle, in sicer, se znebiti vsek ukazov razen enega.
Zanimiva posedica tega je dejstvo, da lahko ko pišemo strojno kodo popolnoma spustimo polje z instructijo, ostanejo le še njeni argumenti.

Jaz sem se raje odločil za 2 instrukciji, ker se njuni rabi ne prekrivata zelo dosti, saj med drugim tudo operirata na različnih magnitudah količine podatkov, je posledica te adicije le lažje pisanje programov.
Odločil sem se, da mi je težavnost pisanja programov brez prevajalnika pomembna, ker bi sicer ta naloga vzela še dosti več časa, če bi rabil napisati še prevajalnik.

\subsection{Instrukcije}
Obe instrukciji prejmeta 2 naslova iz rama\footnote{naslov ni nujno povezan z ramom, glej copy instrukcijo} in en meta bit.
V moji izvedbi sem se odločil za 7 bitne\footnote{Ta izbira je arbitrarna, arhitektura podpira n bitne naslove. Tega sem izbral ker je posledična dolžina ukaza v bitni kodi potenca števila 2.} ram naslove.
Za pridobivanje bitnega zapisa preprosto napišemo 1.\ naslov, 2.\ naslov, cifro zeljene instrukcije in meta bit.
Meta bit je nastal zaradi poravnave dolzine ukaza na 2 byta, kar je naredilo pisanje zbirnika in razbirnika nekoliko lažje.
Obe instrukciji se obnasata po principu, da vzameta podatke iz 1.\ naslova in rezultat shranita na 2.\ naslov.

\subsubsection{Instrukcija ``16c''}
To je 1.\ instrukcija oznacena z 0 v binarni obliki.
Njena notacija izhaja iz daljšega imena \textit{copy 16 bits}
Deluje tako, da od njenega 1.\ podanega naslova in še zaporedno nasledjih 15 registrov prekopira v začasen pomnilnik, potem pa jih prekopira na 2.\ naslov in na zaporednih 15 registrov za njim.
Odločitev da bo to 1.\ instrukcija izhaja iz tega, da so same ničle v programu interpretirane kot ukaz brez posledic, kar je uporabno predvsem, ko rabim kaj poravnati na naslov, ki je par mest nižji.
Na začetku je bila zasnovana kot skoraj jump instrukcija, saj z nandom ni mogoče vseh bitov v programskem števcu hkrati spremeniti na željeno vrednost.
Posledica spremembe enega pa po enega bita, bi bil skok takoj po 1.\ spremembi saj kontrolna enota vedno preveri števec pred nalaganjem nove instrukcije.

Ko sem kasneje dodal še meta bit, sem se odločil da se bo kopiranje zgodilo iz programskega spomina.
Zaradi tega je nalaganje konstant, kot so nizi ali pa naslovi funkcij postali zelo preprosti in hitri.
Limitacija tega je, da sem uporabil 7 bitni naslov za pridobivanje podatkov iz pomnilnika opisanega z 16 biti.
Zaradi tega večina pomnilnika še vedno ni na voljo, kot rešitev temu pa sem se odločil, da sem uporabil skrite registre kot nastavitev strani programskega pomnilnika.

Skriti biti nastanejo kot stranski učinek slabe definicije zaporednih registrov.
Kaj se zgodi če nekaj skopiramo na zadnji register?
Zdi se mi da je najbolj uporaben odgovor, da rečem da so za ``zadnjim registrom'' še skriti registri.
Do njihove vsebine se da dostopati le z c16 ukazom, kar se mi ne zdi problem, saj menim, da bo ta konfiguracija redko spremenjena čez potek programa.

\subsubsection{Instrukcija ``Nox''}
To je 2.\ instrukcija oznacena z 1 v binarni obliki.
Ime izhaja iz njenega kratkega opisa: \textit{Nanad or Xor}.
Najprej sem probal uporabiti le XOR, kot edini ukaz za minpulacijo bitov, vendar sem hitro ugotovil, da se iz samo XORa ne da rekonstuirati vseh ostalih logičnih vrat.
Zato sem se odločil še za naj pogosteje izbrana univerzalna vrata NAND.\@

Ta so s seboj privlekla nove probleme kot npr.\ pogojni skoki naprej so postali zelo dragi.
Programski števec bi lahko bil viden samo c16 ukazu, vendar bi to preprečilo relativne skoke, kjer spremenim le 1 bit v njem.
Pogojni relativni skoki so nadaljevanje tega. Ker vem kje se nahaja trenuten ukaz, lahko vem v kakšnem stanju je nek bit v programskem števcu.
S kombiniranjem enice v programskem števcu in nekega podatka v ramu lahko skočim nazaj, samo če je tudi podatek v ramu enica.
Pogojen skok naprej ni izvedljiv na tak način. Saj bo na enobitnem mesu, če ga želimo povečati morala biti ničla.
Nand pravi, da če je kateri koli izmed argumentov 0, da bo rezultat vedno 1, kar pomeni da naš \textit{pogoj} ni bil upoštevan.

Zaradi dragih skokov in lahke ponastavitve celice na 0, sem se odločil da dodam še XOR.\@
Par vrat sem kombiniral v 1 instrukcijo, kjer meta bit izbira med njima.

\begin{displaymath}
  f(A,B,M) =
  \begin{cases}
    Nand(*A\footnote{*N pomeni priklic iz rama z naslovom N}, *B) \rightarrow *B & M=0\\
    Xor(*A, *B) \rightarrow *B & M=1
  \end{cases}
\end{displaymath}
Oz.\ zapisano v logični notaciji.
\begin{displaymath}
  \overline{(AB)}(A+B+\overline{C})
\end{displaymath}

\subsection{Enobitni registri}
%vsi registri so eneaki, samo eni so bol enaki
Kot ram sem si zamislil \textit{trak} enobitnih registrov.
Zaradi preprostosti, je programski števec preslikan čez prvih 16 registrov, da lahko tudi ukaz Nox z njem operira.
Ves I/O je tudi preslikan na registre, in sicer na prve štirji za števcem.
Število vseh registrov je funkcija dolžine naslova rama in velikosti programskega števca.
Velikost programskega števca je potrebno upoštevati, saj je glede na njega definiran ukaz za kopiranje, in polsedica ukaza za kopirajne so skriti registri.
\begin{center}
\begin{displaymath}
  F(N,P)=2^{N}+P-1
\end{displaymath}
\text{N je dolžina binarnega naslova, P je programski števec}
\end{center}

\subsection{Komunikacija z resničnim svetom}
Za standarden izhod in vhod, sem se odločil da bom implementiral svojo 4 žično komunikacijo.
Ta lahko asinhrono bere informacije po bitih, ker ne morem garantirati dovolj rama, da bi lahko avomatsko pisal na konec nekega stacka, interrupti pa bi tudi dodali ogromno kompleksnosti, saj bi rabil dodati 16 nedosegljivih registrov za callback in novo instrukcijo, ki bi skočila na ta naslov.
Lepa lastnost štirižičnega protokola je tudi, da se dve napravi z lahkoto skupaj poveže, saj moramo le izhode iz ene priklopti v vhode druge.
\begin{center}
  \begin{tabular}{ccc}
    $A_{OUT}  $ & \texttiming{LHHHLLLLLL} & $B_{IN}$\\
    $A_{OUT_A}$ & \texttiming{LLHZLLLLLL} & $B_{IN_A}$\\
    $A_{IN}   $ & \texttiming{LLLLLHHHHL} & $B_{OUT}$\\
    $A_{IN_A} $ & \texttiming{LLLLLLHZLL} & $B_{OUT_A}$
  \end{tabular}

  \text{primer pošiljanja enice od A do B in od B do A}
  %\label{tim:foobar}
\end{center}
Za pošiljanje informacij najprej počakaš da je $OUT_{A}$ dovoljen, torej 0.
Nato lahko pišemo kar hočemo v $OUT$, dokler ne želimo vrednosti \textit{oddati}, kar naredimo s tem da napišemo enico na $OUT_{A}$.

Za prejemanje informacij je podoben postopek.
Začnemo z Preverjanjem $IN_{A}$, kot da bi gledali nabiralnik, če nam je poštar kaj prinesel.
Čim dobimo napisano enico, smemo interpretirati karkoli je v $IN$, kot podatke.
Da dobimo naslednji znak, priklopimo pulldown upor na $IN_{A}$.
To druga naprava zazna in čimprej spusti $IN_{A}$ na 0.


\section{Izdelava} %TODO
Za uspešno izdelavo sem se odločil da bom potreboval okolje, kjer lahko testiram ideje o spremembah arhitekture in mesto za testiranje mojih programov.
Zato sem se lotil pisanja virtualnega stroja, ker pa je teško vedeti kdaj ti je uspelo, sem začel delati na assemblerju.
Seveda je izdelava tega tudi težka, zato sem razvil še dissasembler, da preverim delovanje asemblerja.
Izdelava le tega je bila nekoliko lažja,  vendar sem še zmeraj čez par dni našel večjo napako pri de šifriranju ukazov.

\subsection{Zbirnik (assembler)}
Assembler se sprehodi čez celotno datoteko in vsako vrsico klasificira, kot eno izmed 4 možnosti.
1. Komentar,
2. Surovi binarni podatki,
3. Premik v programu,
4. Instrukcija v procesorju;,
5. Naslov.
Še preden pa se moj program sprehodi čez input, ga podam predprocesorju.
\subsubsection{Preprocessor}
Preprocessor skrbi za dodajanje večih datotek skupaj in dešifriranje macrotov ter definicij.
Nasm je precej popularen assembler, ki mi dovoli, da zlahkoto pokljičem le njegov predprocesor.
Bolj primeren kot c-jev predprocesor je, ker zaradi formata zbornika, ne smemo zanemariti novih vrstic.
\subsubsection{Dissasembler}
Seveda je bilo nekaj problemov na katere sem naletel med potjo do assemblerja.
Še sedaj občasno odprem dissasembler, da vidim če generiram pravilen program.
Kot najhitrejši način reševanja problemov v assembleru sem se odločil, da bom napisal še majhen program, ki bo izpisal ukaze in njihove argumente.
%TODO oliver pomagal

\subsubsection{Ugibanje ukazov}
Na moje veliko presenečenje na internetu še nisem našel vseh logičnih vrat še nisem našel razstavljenih na nand in xor ukaze z assignmentom.
V namen avtomatiziranja postopka iskanja kombinacije nandov, ki bi recimo sešteli 2 enobitni številki, sem spisal program ki proba najti vsa možna dejanja na n celicah.
za kater koli n, ki je večji od 2, je to postal ne zdržljivo dolg proces (predvidevam da bi trajalo nekaj tednov),  zato sem napisal tudi več nizno implementacijo v C-ju.

%\section{Virtualna implementacija}
%$Da zares lahko pokažem delovanje naprave, moram nekako prikazati kako deluje, in to na najlažji način dosežem. %TODO
%\subsection{cellular automata}
\section{Zaključek}
\subsection{Hipoteze}
\begin{itemize}
  \item Bolj kot je arhitektura simplistična, hitreje in bolj efektivno deluje.

        Ni tako preproste povezave, kot sem si jo na začetku zamislil, vendar drži, da bo manj tranzistorjev hitreje reagiralo in porabilo manj energije.

  \item Moja minimalna arhitektura je Turing complete.
  \item Tudi brez predpostavke neskončnega rama je možno izvesti malo zapletenejšo komputacijo.

        To dvoje očitno drži saj lahko simuliram celice, s pravili na način, da so že same po sebi turing complete.
\end{itemize}

\section{Nadaljne raziskave}
Zdi se mi pomembno omeniti, da lahko med tem ko ohranimo preprostost dizajna moje eno-bitne arhitekture, močno razširimo njeno moč, s tem da jo postavimo kot generator programskega spomina sebe.

\pagebreak
\section{Viri in literatura}
$[1]$ dosegljivo: \url{https://uops.info/} [23.3.2022]\\
$[2]$ dosegljivo: \url{https://cs.stanford.edu/people/eroberts/courses/soco/projects/risc/risccisc/} [23.3.2022]\\
$[3]$ dosegljivo: \url{https://wpmedia.wolfram.com/uploads/sites/13/2018/02/15-1-1.pdf} [23.3.2022]\\

%\pagebreak
%\section{Viri slik}
\end{document}
